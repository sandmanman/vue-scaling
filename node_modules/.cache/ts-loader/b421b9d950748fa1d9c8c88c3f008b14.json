{"remainingRequest":"/Users/zhangyufan/em/testPro/vue-scale/node_modules/babel-loader/lib/index.js!/Users/zhangyufan/em/testPro/vue-scale/node_modules/ts-loader/index.js??ref--14-2!/Users/zhangyufan/em/testPro/vue-scale/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js??ref--13-0!/Users/zhangyufan/em/testPro/vue-scale/src/helper/poper.ts","dependencies":[{"path":"/Users/zhangyufan/em/testPro/vue-scale/src/helper/poper.ts","mtime":1573474128000},{"path":"/Users/zhangyufan/em/testPro/vue-scale/node_modules/cache-loader/dist/cjs.js","mtime":1573721989004},{"path":"/Users/zhangyufan/em/testPro/vue-scale/node_modules/babel-loader/lib/index.js","mtime":1574242632071},{"path":"/Users/zhangyufan/em/testPro/vue-scale/node_modules/ts-loader/index.js","mtime":1574332289889},{"path":"/Users/zhangyufan/em/testPro/vue-scale/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js","mtime":1574242646426}],"contextDependencies":[],"result":["import _Promise from \"/Users/zhangyufan/em/testPro/vue-scale/node_modules/@babel/runtime-corejs2/core-js/promise\";\nimport { hasOwn } from './o';\nexport var getScroll = function getScroll(target, top) {\n  var prop = top ? 'pageYOffset' : 'pageXOffset';\n  var method = top ? 'scrollTop' : 'scrollLeft';\n  var ret = target[prop];\n\n  if (typeof ret !== 'number') {\n    ret = window.document.documentElement[method];\n  }\n\n  return ret;\n};\nexport var setLeftFn = function setLeftFn(self, render) {\n  var before = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n  var after = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n\n  if (!render) {\n    return new _Promise(function (resolve) {\n      resolve();\n    });\n  }\n\n  var _render$getBoundingCl = render.getBoundingClientRect(),\n      x = _render$getBoundingCl.x,\n      width = _render$getBoundingCl.width;\n\n  var offsetLeft = x;\n  before();\n  return new _Promise(function (resolve) {\n    self.$nextTick(function () {\n      var _self$$refs$popElem = self.$refs.popElem,\n          popElem = _self$$refs$popElem === void 0 ? {\n        offsetWidth: 0\n      } : _self$$refs$popElem;\n      var tooltipWidth = popElem.offsetWidth;\n      var posX = offsetLeft;\n      after(); // top left right bottom\n      // topLeft topRight bottomLeft bottomRight\n      // leftTop leftBottom rightTop rightBottom\n\n      if (self.isVerCenter) {\n        // top bottom\n        posX = offsetLeft + width / 2 - tooltipWidth / 2;\n      } else if (self.isVerLeft) {\n        // leftTop left leftBottom\n        posX = offsetLeft - tooltipWidth - self.interval;\n      } else if (self.isVerEndRight) {\n        // topRight bottomRight\n        posX = offsetLeft + width - tooltipWidth;\n      } else if (self.isVerRight) {\n        // rightTop right rightBottom\n        posX = offsetLeft + width + self.interval;\n      }\n\n      resolve(posX + getScroll(window));\n    });\n  });\n}; // end setLeftFn\n\nexport var setTopFn = function setTopFn(self, render) {\n  var before = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n  var after = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n\n  if (!render) {\n    return new _Promise(function (resolve) {\n      resolve();\n    });\n  }\n\n  var _render$getBoundingCl2 = render.getBoundingClientRect(),\n      y = _render$getBoundingCl2.y,\n      height = _render$getBoundingCl2.height;\n\n  var offsetTop = y;\n  before();\n  return new _Promise(function (resolve) {\n    self.$nextTick(function () {\n      var _self$$refs$popElem2 = self.$refs.popElem,\n          popElem = _self$$refs$popElem2 === void 0 ? {\n        offsetHeight: 0\n      } : _self$$refs$popElem2;\n      var tooltipHeight = popElem.offsetHeight;\n      var posY = offsetTop;\n      after(); // top left right bottom\n      // topLeft topRight bottomLeft bottomRight\n      // leftTop leftBottom rightTop rightBottom\n\n      if (self.isHorCenter) {\n        // left right\n        posY = offsetTop + height / 2 - tooltipHeight / 2;\n      } else if (self.isHorEndBottom) {\n        // leftBottom rightBottom\n        posY = offsetTop + height - tooltipHeight;\n      } else if (self.isHorTop) {\n        // top topLeft topRight\n        posY = offsetTop - tooltipHeight - self.interval;\n      } else if (self.isHorBottom) {\n        // bottom bottomLeft bottomRight\n        posY = offsetTop + height + self.interval;\n      }\n\n      resolve(posY + getScroll(window, true));\n    });\n  });\n}; // end setTopFn\n\nexport var setPostion = function setPostion(self, refName) {\n  var popElem = self.$refs.popElem;\n\n  if (hasOwn(self.$refs, refName) && hasOwn(self.$refs, 'popElem')) {\n    setLeftFn(self, self.$refs[refName]).then(function (left) {\n      if (left) {\n        popElem.style.left = \"\".concat(left, \"px\");\n      }\n    });\n    setTopFn(self, self.$refs[refName]).then(function (top) {\n      if (top) {\n        popElem.style.top = \"\".concat(top, \"px\");\n      }\n    });\n  }\n};\nexport var getEventType = function getEventType(type) {\n  if (type === 'mouseenter' || type === 'mouseleave') {\n    return 'hover';\n  }\n\n  return type;\n};",{"version":3,"sources":["/Users/zhangyufan/em/testPro/vue-scale/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js??ref--13-0!/Users/zhangyufan/em/testPro/vue-scale/src/helper/poper.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n  hasOwn,\r\n} from './o';\r\n\r\nexport const getScroll = (target: any, top?: boolean): number => {\r\n  const prop = top ? 'pageYOffset' : 'pageXOffset';\r\n  const method = top ? 'scrollTop' : 'scrollLeft';\r\n\r\n  let ret = target[prop];\r\n\r\n  if (typeof ret !== 'number') {\r\n    ret = window.document.documentElement[method];\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nexport const setLeftFn = (self: any, render: Element, before = () => {}, after = () => {}) => {\r\n  if (!render) {\r\n    return new Promise((resolve) => { resolve(); });\r\n  }\r\n  const { x, width }: any = render.getBoundingClientRect();\r\n  const offsetLeft = x;\r\n  before();\r\n  return new Promise((resolve) => {\r\n    self.$nextTick(() => {\r\n      const { popElem = { offsetWidth: 0 } } = self.$refs;\r\n      const tooltipWidth = popElem.offsetWidth;\r\n      let posX = offsetLeft;\r\n      after();\r\n      // top left right bottom\r\n      // topLeft topRight bottomLeft bottomRight\r\n      // leftTop leftBottom rightTop rightBottom\r\n      if (self.isVerCenter) {\r\n        // top bottom\r\n        posX = offsetLeft + width / 2 - tooltipWidth / 2;\r\n      } else if (self.isVerLeft) {\r\n        // leftTop left leftBottom\r\n        posX = offsetLeft - tooltipWidth - self.interval;\r\n      } else if (self.isVerEndRight) {\r\n        // topRight bottomRight\r\n        posX = offsetLeft + width - tooltipWidth;\r\n      } else if (self.isVerRight) {\r\n        // rightTop right rightBottom\r\n        posX = offsetLeft + width + self.interval;\r\n      }\r\n      resolve(posX + getScroll(window));\r\n    });\r\n  });\r\n}; // end setLeftFn\r\n\r\nexport const setTopFn = (self: any, render: Element, before = () => {}, after = () => {}) => {\r\n  if (!render) {\r\n    return new Promise((resolve) => { resolve(); });\r\n  }\r\n  const { y, height }: any = render.getBoundingClientRect();\r\n  const offsetTop = y;\r\n  before();\r\n  return new Promise((resolve) => {\r\n    self.$nextTick(() => {\r\n      const { popElem = { offsetHeight: 0 } } = self.$refs;\r\n      const tooltipHeight = popElem.offsetHeight;\r\n      let posY = offsetTop;\r\n      after();\r\n      // top left right bottom\r\n      // topLeft topRight bottomLeft bottomRight\r\n      // leftTop leftBottom rightTop rightBottom\r\n      if (self.isHorCenter) {\r\n        // left right\r\n        posY = offsetTop + height / 2 - tooltipHeight / 2;\r\n      } else if (self.isHorEndBottom) {\r\n        // leftBottom rightBottom\r\n        posY = offsetTop + height - tooltipHeight;\r\n      } else if (self.isHorTop) {\r\n        // top topLeft topRight\r\n        posY = offsetTop - tooltipHeight - self.interval;\r\n      } else if (self.isHorBottom) {\r\n        // bottom bottomLeft bottomRight\r\n        posY = offsetTop + height + self.interval;\r\n      }\r\n      resolve(posY + getScroll(window, true));\r\n    });\r\n  });\r\n}; // end setTopFn\r\n\r\nexport const setPostion = (self: any, refName: string) => {\r\n  const { popElem } = self.$refs;\r\n  if (hasOwn(self.$refs, refName) && hasOwn(self.$refs, 'popElem')) {\r\n    setLeftFn(self, self.$refs[refName]).then((left) => {\r\n      if (left) {\r\n        popElem.style.left = `${left}px`;\r\n      }\r\n    });\r\n    setTopFn(self, self.$refs[refName]).then((top) => {\r\n      if (top) {\r\n        popElem.style.top = `${top}px`;\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\nexport const getEventType = (type: string) => {\r\n  if (type === 'mouseenter' || type === 'mouseleave') {\r\n    return 'hover';\r\n  }\r\n  return type;\r\n};\r\n"],"sourceRoot":""}]}